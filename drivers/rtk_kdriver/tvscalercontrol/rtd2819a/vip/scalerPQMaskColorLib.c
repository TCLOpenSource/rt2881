/*==========================================================================
    * Copyright (c)      Realtek Semiconductor Corporation, 2006
  * All rights reserved.
  * ========================================================================*/

/*================= File Description =======================================*/

/**
 * @file
 * 	This file is for PQMask tuning pq related parameters functions.
 *
 * @author 	Wei Yuan Hsu
 * @date 	20210323
 * @version 0.1
 */

/****************************** Header files ******************************/
// platform
#include <rtd_log/rtd_module_log.h>
#include <mach/rtk_platform.h>
#include <scaler/vipRPCCommon.h>
#include <linux/string.h>
// library
#include <tvscalercontrol/vip/scalerColor.h>
#include <rtk_ai.h>
#include <tvscalercontrol/vip/scalerPQMaskColorLib.h>
#include <tvscalercontrol/vip/scalerPQMaskCtrl.h>
#include <rtk_kadp_se.h>
#include <tvscalercontrol/vip/ai_pq.h>
#include <tvscalercontrol/vip/color.h>
#include <tvscalercontrol/vip/nr.h>
#include <tvscalercontrol/vip/peaking.h>
#include <tvscalercontrol/vip/localcontrast.h>
#include <tvscalercontrol/vip/icm.h>

#include <tvscalercontrol/scaler/scalercolorlib.h>
#include <vgip_isr/scalerAI.h>
#include <scaler/vipCommon.h>
/****************************** Configurations ******************************/
#define TAG_NAME "VPQMASK_COLOR"
extern unsigned char bBinAIPQ_Table;
extern SLR_VIP_TABLE_AIPQ m_VIP_AIPQTable;	
extern short AI_PQMaskWeightTbl_SQM_TBL[AI_RESOLUTION_TYPE_NUM][PQMASK_MODULE_NUM];

#if 0 // ml9 hw not support
/****************************** Gobal module parameters ******************************/
static PQMASK_DEPTH_CURVE_LOCK_T PQMaskTableLock[PQMASK_COLOR_PALETTE_MAX];
static unsigned int PQMaskPalette[PQMASK_COLOR_PALETTE_MAX][MODULE_GRP_MAX][PQMASK_MAPCURVE_LEN];
static PQMASK_COLOR_MGR_T PQMaskColorMgr = {
	// ModuleSetting
	{
		// Nr
		{
			1,
			1,
			1,
		},
		// ICM
		{
			// object saturation
			{
				// object 1 (sky)
				{
					1, // enable
					1, // input sel
					32, // glb ratio
					1, // gain by sat enable
					0, // gain by sat mode
					{ 0, 6, 11, 16, 22, 28, 31, 31 },
					0, // gain by hue enable
					{
						/* 0*/  0,  0,  0,  0,  0,  0,  0,  0, /* 8*/  0,  0,  0,  0,  0,  0,  0,  0, /*16*/  0,  0,  0,  0,  0,  0,  0,  0,
						/*24*/  0,  0,  3, 11, 24, 31, 31, 31, /*32*/ 31, 31, 29, 25, 19, 14, 11,  9, /*40*/  7,  5,  3,  1,  0,  0,  0,  0,
					},
				},
				// object 2 (grass)
				{
					1, // enable
					1, // input sel
					32, // glb ratio
					// gain by sat
					1, // gain by sat enable
					0, // gain by sat mode
					{ 0, 4, 9, 15, 22, 29, 31, 31 },
					0, // gain by hue enable
					{
						/* 0*/  4,  4,  4,  4,  4,  4,  8, 16, /* 8*/ 31, 31, 31, 31, 31, 31, 31, 31, /*16*/ 31, 31, 31, 31, 31, 31, 31, 26,
						/*24*/ 22, 16,  8,  4,  4,  4,  4,  4, /*32*/  4,  4,  4,  4,  4,  4,  4,  4, /*40*/  4,  4,  4,  4,  4,  4,  4,  4,
					},
				}
			},
			// object hue
			{
				// object 1
				{
					0, // enable
					0, // input sel
					0, // target hue
					0, // gain by hue enable
					{
						/* 0*/  0,  0,  0,  0,  0,  0,  0,  0, /* 8*/  0,  0,  0,  0,  0,  0,  0,  0, /*16*/  0,  0,  0,  0,  0,  0,  0,  0,
						/*24*/  0,  0,  0,  0,  0,  0,  0,  0, /*32*/  0,  0,  0,  0,  0,  0,  0,  0, /*40*/  0,  0,  0,  0,  0,  0,  0,  0,
					},
				},
				// object 2 (face)
				{
					0, // enable
					0, // input sel
					0, // target hue
					0, // gain by hue enable
					{
						/* 0*/  0, 10, 24, 20,  8,  0,  0,  0, /* 8*/  0,  0,  0,  0,  0,  0,  0,  0, /*16*/  0,  0,  0,  0,  0,  0,  0,  0,
						/*24*/  0,  0,  0,  0,  0,  0,  0,  0, /*32*/  0,  0,  0,  0,  0,  0,  0,  0, /*40*/  0,  0,  0,  0,  0,  0,  0,  0,
					},
				},
			},
			// intensity
			{
				0, // enable
				2, // input sel
			},
			6, 0,	// Sat gain, offset
			32, 0,	// Int gain, offset
		},
		// Sharpness
		{
			1,
			1,
			{ 6, 17, 28, 39, 50, 90, 130, 170, 210 }, // SobelUpbnd
			1,
			{ 5, 15, 25, 40, 50, 75, 100, 125, 150 }, // ZDiffUpbnd
			1,
			{ 32, 28, 24, 20, 8, 4, 2, 1, 0 }, // TextUpbnd
			1,
			{ 44, 32, 21, 10, 0, 0, 0, -12, -29, }, // TextLV
			{ -72, -50, -36, -24, 0, 0, 18, 36, 64, }, // TextGainPos
			{ -72, -50, -36, -24, 0, 0, 18, 36, 64, }, // TextGainPosV
			{ -104, -68,  -54, -24, -5, 0, 26, 54, 108, }, // TextGainNeg
			{ -104, -68,  -54, -24, -5, 0, 26, 54, 108, }, // TextGainNegV
			{ -72, -50, -36, -24, 0, 0, 18, 36, 64, }, // TextHVPos
			{ -72, -50, -36, -24, 0, 0, 18, 36, 64, }, // TextHVPosV
			{ -104, -68,  -54, -24, -5, 0, 26, 54, 108, }, // TextHVNeg
			{ -104, -68,  -54, -24, -5, 0, 26, 54, 108, }, // TextHVNegV
			{ 39, 29, 19, 0, 0, 0, -10, -24, }, // TextLVV
		},
		// LocalContrast
		{
			1, 0, 64,
			1, 0, 64,
		},
#if 0 // SRNN_TBD
		// SRNN_IN
		{
			0, 0,
			0, 0,
 		},
		// SRNN_OUT
		{
			0, 0,
			0, 0,
 		}
#endif
	},
	// SemanticWeightTbl
	{
		//	basic,	sky,	people,	sea,	plant,	arti,
		//											text
		{	128,	196,	128,	128,	128,	 64	},	// NR
		{	128,	192,	128,	160,	128,	128	},	// DECON
		{	128,	192,	128,	 96,	184,	160	},	// EDGE
		{	128,	 16,	128,	192,	216,	248	},	// TEXT
		{	128,	128,	128,	128,	128,	128	},	// H
		{	128,	176,	128,	128,	148,	128	},	// S
		{	128,	130,	128,	128,	116,	128	},	// I
		{	128,	 32,	128,	192,	208,	224 },	// LC
		{	128,	128,	128,	128,	128,	128 },	// SRNN_IN_0
		{	128,	128,	128,	128,	128,	128 },	// SRNN_IN_1
		{	128,	128,	128,	128,	128,	128 },	// SRNN_IN_2
		{	128,	128,	128,	128,	128,	128 },	// SRNN_OUT_0
	},
	// DepthWeightTbl
	{
		// NR
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
		// DECON
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
		// EDGE
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
		// TEXT
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
		// HUE
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
		// SAT
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
		// INT
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
		// LC
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
		// SRNN_IN_0
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
		// SRNN_IN_1
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},	
		// SRNN_IN_2
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},			
		// SRNN_OUT_0
		{
			/*  0*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 16*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 32*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 48*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 64*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 80*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/* 96*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*112*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*128*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*144*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*160*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*176*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*192*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*208*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*224*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
			/*240*/ 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128,
		},
	},
	// DefocusWeightTbl
	{
		// NR
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
		// DECON
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
		// EDGE
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
		// TEXT
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
		// HUE
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
		// SAT
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
		// INT
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
		// LC
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
		// SRNN_IN_0
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
		// SRNN_IN_1
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},	
		// SRNN_IN_2
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},			
		// SRNN_OUT_0
		{
			/*  0*/ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
			/* 16*/ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
			/* 32*/ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
			/* 48*/ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
			/* 64*/ 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
			/* 80*/ 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
			/* 96*/ 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
			/*112*/ 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
			/*128*/ 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
			/*144*/ 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
			/*160*/ 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
			/*176*/ 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
			/*192*/ 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
			/*208*/ 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
			/*224*/ 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
			/*240*/ 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255,
		},
	},
	// DefocusEnableTbl, refer to apply defocus blending or not, only 0/1
	{
		1,	// NR
		1,	// DECON
		1,	// EDGE
		1,	// TEXT
		1,	// H
		1,	// S
		1,	// I
		1,	// LC
		1,	// SRNN_IN_0
		1,	// SRNN_IN_1
		1,	// SRNN_IN_2
		1,	// SRNN_OUT_0
	},
	// depth histogram
	{
		// info
		{ 0, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
		// data
		{
			// pts histogram
			0, { 0, },
			// percentage histogram
			0, { 0, },
			// apl
			0,
		}
	},
	// semantic histogram
	{
		// info
		{ 1, AI_SEMANTIC_OUTPUT_WIDTH, AI_SEMANTIC_OUTPUT_HEIGHT, 4, 4 },
		// data
		{
			// pts histogram
			0, { 0, },
			// percentage histogram
			0, { 0, },
			// apl
			0,
		}
	},
	// image by semantic histogram, calculated from ap
	{
		{
			{
				// info
				{ 0, AI_SEMANTIC_OUTPUT_WIDTH, AI_SEMANTIC_OUTPUT_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
		},
	},
	// image by depth histogram
	{ 0, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
	50, // low thl, far <= thl < mid
	200, // high thl, mid <= thl < near
	{
		// far
		{
			// channel y
			{
				// info
				{ 1, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
			// channel u
			{
				// info
				{ 1, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
			// channel v
			{
				// info
				{ 1, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
		},
		// mid
		{
			// channel y
			{
				// info
				{ 1, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
			// channel u
			{
				// info
				{ 1, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
			// channel v
			{
				// info
				{ 1, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
		},
		// near
		{
			// channel y
			{
				// info
				{ 1, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
			// channel u
			{
				// info
				{ 1, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
			// channel v
			{
				// info
				{ 1, AI_DEPTHMAP_WIDTH, AI_DEPTHMAP_HEIGHT, 4, 4 },
				// data
				{
					// pts histogram
					0, { 0, },
					// percentage histogram
					0, { 0, },
					// apl
					0,
				}
			},
		},
	},
	// Status
	{
		0,	// bSceneChange : scene change signal
		0,	// SCRstFrm : scene change TNR frames
		0,	// LocalContrastRstWeight : just record the current LC reset weighting
		0,	// ForceCurFrm : force the current output for a period of times
		1,	// bReloadDepPalette : to reload palette when depth weighting table change
		1,	// bReloadSemPalette : to reload palette when semantic weighting table change
		1,	// bReloadDefocusPalette : to reload palette when defocus weighting table change
		AI_GENRE_TYPE_NUM,	// AiGenre : for PQ tuning
		0,	// bGenerCGStatusChange : AiGenre result CG pattern change (enter/leave CG pattern)
		0,	// Genre_CG_Frm : CG Pattern TNR frames
		0,	// bReloadDepthPalette_AiGenre_CG : to reload the depth palette when CG pattern detected
		0,	// bReloadSemanticPalette_AiGenre_CG : to reload the semantic palette when CG pattern detected
		0,	// bReloadDefocusPalette_AiGenre_CG : to reload the defocus palette when CG pattern detected
		0,	// SrnnInRstWeight : just record the current SRNN in reset weighting
		128,// SrnnOutRstWeight : just record the current SRNN out reset weighting
	},
	// Parameters
	{
		239, 15,	// DepthFusiontRatio_Pre/DepthFusiontRatio_Cur : blending weight on pre/cur depth information
		0, 255, 	// FusionRatio_Dep/FusionRatio_Sem : blending weighting on Depth/Semantic
		0, 		// FusionRatio_Defocus : blending weighting on Defocus/(Semantic, Depth)
		239  , 15, 	// FusionRatio_Pre/FusionRatio_Cur : blending weighting on Pre/Cur
		1, 			// SpatialFltCycle : Cycle
		{    0, 1368,    0, 1368 },	// SEHorCoef : Spatial filter SE horizontal coefficient
		{    0, 1368,    0, 1368 },	// SEVerCoef : Spatial filter SE vertical coefficient
		1, 							// HorOddType : SE hor FIR type ( 0:even 1:odd )
		1, 							// VerOddType : SE ver FIR type ( 0:even 1:odd )
		/* Scene change control */
		1,			// bSceneChangeEnable : enable or disable scene change detection
		320, 		// SceneChangeRstFrm : frame to bypass curve and frame to target cruve
		207, 47 , 	// ScFusionRatio_toRst_Pre/ScFusionRatio_toRst_Cur : blending weight on Pre/Cur toward reset when scene change happend
		247, 7  , 	// ScFusionRatio_toTarget_Pre/ScFusionRatio_toTarget_Cur : blending weight on Pre/Cur toward target when scene change happend
		/* Genre CG pattern control */
		0,			// bGenre_CG_Enable : enable or disable cg pattern detection
		32 ,		// Genre_CG_toTargetFrm : frame to bypass curve and frame to target cruve
		239,  15,	// Genre_CG_FunctionRatio_Pre/Genre_CG_FunctionRatio_Cur : blending weight on Pre/Cur toward target when enter/leave CG pattern
		/* Rounding action */
		0,	// bRoundActionManualSet : force to set rounding action
		1,	// RoundAction_TNR : rounding action selection when pqmask weighting temporal filter
		1,	// RoundAction_DepthTNR : rounding action selection when depth information temporal filter
		1,	// RoundAction_DepthSemFusion : rounding action selection when depth and semantic pqmask weighting fusion
	}
};

/****************************** Internal Functions ******************************/

/****************************** Functions ******************************/

/**
 * @brief
 * init the PQ module settings
 */
void scalerPQMaskColor_init(void) {

	DRV_LC_ToneMapping_PQmask LCTmap;
	DRV_LC_Sharpness_PQmask LCSharp;
	//void * TablePtr = NULL;
	int i=0, j=0;

	rtd_printk(KERN_INFO, TAG_NAME, "[%s] start\n", __FUNCTION__);

	// initial some strutcture
	memset(&PQMaskColorMgr.ImgByDepthHist , 0, PQMASK_DEPDIST_NUM*PQMASK_IMGCH_NUM*sizeof(PQMASK_HIST_T)); // info column is not important
	memset(&PQMaskColorMgr.Status, 0, sizeof(PQMASK_COLOR_STATUS_T));
	memset(&PQMaskColorMgr.SemanticHist.Data, 0, sizeof(PQMASK_HIST_DATA_T));
	memset(&PQMaskColorMgr.DepthHist.Data, 0, sizeof(PQMASK_HIST_DATA_T));
	for(i=0; i<PQMASK_LABEL_NUM; i++) {
		for(j=0; j<PQMASK_IMGCH_NUM; j++) {
			// first unit info is the real information
			if( i==0 && j==0 ) {
				memset(&PQMaskColorMgr.ImgBySemanticHist[i][j].Data, 0, sizeof(PQMASK_HIST_DATA_T));
			} else {
				memset(&PQMaskColorMgr.ImgBySemanticHist[i][j], 0, sizeof(PQMASK_HIST_T));
			}
		}
	}
	memset(&LCTmap, 0, sizeof(DRV_LC_ToneMapping_PQmask));
	memset(&LCSharp, 0, sizeof(DRV_LC_Sharpness_PQmask));
	memset(PQMaskPalette, 0x80, sizeof(unsigned int)*PQMASK_COLOR_PALETTE_MAX*MODULE_GRP_MAX*PQMASK_MAPCURVE_LEN); // reset to 128 to avoid some obvious problem

	// initial the lock
	for(i=0; i<PQMASK_COLOR_PALETTE_MAX; i++) {
		spin_lock_init(&PQMaskTableLock[i].CurveLock);
		PQMaskTableLock[i].bIsInit = 1;
	}

#if 1	// table from bin
	fwif_color_Set_Semantic_Depth_Weight_from_AIPQ_BIN_by_NNSR_mode();
	fwif_color_Set_Semantic_Depth_Weight_from_nnsr_BIN_by_NNSR_mode();
	fwif_color_Set_DeFocus_Weight_from_AIPQ_BIN_by_NNSR_mode();
	fwif_color_Set_DeFocus_Weight_from_nnsr_BIN_by_NNSR_mode();
#else		// copy semantic/depth weighting from table
	TablePtr = scaler_VIP_PQMask_GetSemanticTable(1);
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_SEMANTIC) != 0 ) {
		if( TablePtr != NULL ) {
			memcpy((void *)PQMaskColorMgr.SemanticWeightTbl, TablePtr, PQMASK_MODULE_NUM*PQMASK_LABEL_NUM*sizeof(unsigned char));
			//memcpy((void *)PQMaskColorMgr.SemanticWeightTbl, TablePtr, PQMASK_MODULE_SRNN_IN_0*PQMASK_LABEL_NUM*sizeof(unsigned char));
		} else {
			rtd_printk(KERN_EMERG, TAG_NAME, "[%s] init default semantic weight table fail\n", __FUNCTION__);
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_SEMANTIC);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_SEMANTIC);
	}

	TablePtr = scaler_VIP_PQMask_GetDepthTable(1);
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEPTH) != 0 ) {
		if( TablePtr != NULL ) {
			memcpy((void *)PQMaskColorMgr.DepthWeightTbl, TablePtr, PQMASK_MODULE_NUM*PQMASK_MAPCURVE_LEN*sizeof(unsigned char));
			//memcpy((void *)PQMaskColorMgr.DepthWeightTbl, TablePtr, PQMASK_MODULE_SRNN_IN_0*PQMASK_MAPCURVE_LEN*sizeof(unsigned char));
		} else {
			rtd_printk(KERN_EMERG, TAG_NAME, "[%s] init default depth weight table fail\n", __FUNCTION__);
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEPTH);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEPTH);
	}

#endif	


	// Defocus TBD, load table from aipq bin in the future
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEFOCUS) != 0 ) {
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEFOCUS);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEFOCUS);
	}

	// NR
	// (drvif_color_DRV_SNR_PQ_Mask)(drvif_color_Set_Block_DeContour_Ctrl), setting in vip_default_panel.c (semantic_en)
	drvif_color_DRV_SNR_PQ_Mask_Enable(PQMaskColorMgr.ModuleSetting.Nr.bNrEnable);
	// De-contour
	// setting in pq_misc_table (semantic_alpha)
	drvif_color_Set_I_De_Contour_PQ_Mask_Enable(PQMaskColorMgr.ModuleSetting.Nr.bIDecontEnable);
	drvif_color_Set_Block_DeContour_PQ_Mask_Enable(PQMaskColorMgr.ModuleSetting.Nr.bIBlockDecontEnable);

	// ICM
	drvif_color_icm_pqmask_inputAdjust(
		PQMaskColorMgr.ModuleSetting.ICM.IntGain,
		PQMaskColorMgr.ModuleSetting.ICM.IntOffset,
		PQMaskColorMgr.ModuleSetting.ICM.SatGain,
		PQMaskColorMgr.ModuleSetting.ICM.SatOffset
	);
	drvif_color_icm_pqmask_enable(
		PQMaskColorMgr.ModuleSetting.ICM.Intensity.bEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[0].bEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[1].bEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[0].bEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[1].bEnable
	);
		// saturation channel control
	drvif_color_icm_pqmask_SatGainBySat(
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[0].bGainBySatEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[0].GainBySatMode,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[1].bGainBySatEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[1].GainBySatMode,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[0].GainBySatCurve,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[1].GainBySatCurve
	);
	drvif_color_icm_pqmask_SatHue_byhue_Ctrl(
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[0].bGainByHueEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[1].bGainByHueEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[0].GainByHueCurve,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[1].GainByHueCurve,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[0].bGainByHueEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[1].bGainByHueEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[0].GainByHueCurve,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[1].GainByHueCurve,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[0].TargetHue,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[1].TargetHue
	);
	drvif_color_icm_pqmask_Sat_Final_Ctrl(
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[0].GlbBlendRatio,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[1].GlbBlendRatio
	);
	drvif_color_icm_pqmask_source_mux(
		PQMaskColorMgr.ModuleSetting.ICM.Intensity.InputSel,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[0].InputSel,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectSat[1].InputSel,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[0].InputSel,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[1].InputSel
	);
#if 0
		// hue channel control
	drvif_color_icm_pqmask_Hue_byhue_Ctrl(
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[0].bGainByHueEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[1].bGainByHueEnable,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[0].GainByHueCurve,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[1].GainByHueCurve,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[0].TargetHue,
		PQMaskColorMgr.ModuleSetting.ICM.ObjectHue[1].TargetHue,
	);
#endif
	drvif_color_icm_Set_pqmask_debug_gain(3);

	// Sharpness
	scalerPQMaskColor_UpdateLabelPK();
	drvif_set_labelpk_enable(PQMaskColorMgr.ModuleSetting.Sharpness.bLabelSharpnessEnable);

	// Localcontrast
	// TmapFactor = (weight/2 - offset)
	// ShpRatio = ((ratio*weight/128) * gain) / 64
	LCTmap.lc_PQmask_tmap_En = PQMaskColorMgr.ModuleSetting.LocalContrast.bToneMappingEnable;
	LCTmap.lc_PQmask_offset = PQMaskColorMgr.ModuleSetting.LocalContrast.ToneMappingOffset;
	LCTmap.lc_PQmask_tmap_gain = PQMaskColorMgr.ModuleSetting.LocalContrast.ToneMappingGain;
	LCSharp.lc_PQmask_shp_En = PQMaskColorMgr.ModuleSetting.LocalContrast.bSharpEnable;
	LCSharp.lc_PQmask_shp_gain = PQMaskColorMgr.ModuleSetting.LocalContrast.SharpGain;
	LCSharp.lc_PQmask_shp_offset = PQMaskColorMgr.ModuleSetting.LocalContrast.SharpOffset;
	
	drvif_color_set_LC_Tonemapping_PQmask(&LCTmap);
	drvif_color_set_LC_Sharpness_PQmask(&LCSharp);

	// SRNN_TBD ?

	rtd_printk(KERN_INFO, TAG_NAME, "[%s] end\n", __FUNCTION__);
}

/**
 * @brief
 * clean up the related resource
 */
void scalerPQMaskColor_exit(void) {
	rtd_pr_vpq_info( "[%s] start\n", __FUNCTION__);
	rtd_pr_vpq_info( "[%s] end\n", __FUNCTION__);
}

/**
 * @brief
 * disable all the PQ mask related HW block
 */
void scalerPQMaskColor_disable(void) {

	DRV_LC_ToneMapping_PQmask LCTmap;
	DRV_LC_Sharpness_PQmask LCSharp;

	rtd_pr_vpq_info( "[%s] start\n", __FUNCTION__);

	memset(&LCTmap, 0x0, sizeof(DRV_LC_ToneMapping_PQmask));
	memset(&LCSharp, 0x0, sizeof(DRV_LC_Sharpness_PQmask));
	LCSharp.lc_PQmask_shp_gain = 64;
	LCTmap.lc_PQmask_tmap_gain = 64;

	drvif_color_DRV_SNR_PQ_Mask_Enable(0);
	drvif_color_Set_I_De_Contour_PQ_Mask_Enable(0);
	drvif_color_Set_Block_DeContour_PQ_Mask_Enable(0);
	//drvif_color_icm_Set_pqmask_hue(0, 32);
	//drvif_color_icm_Set_pqmask_sat(0, 32, 0);
	//drvif_color_icm_Set_pqmask_int(0, 32, 0);
	drvif_color_icm_pqmask_enable(0, 0, 0, 0, 0);
	drvif_set_labelpk_enable(0);
	drvif_color_set_LC_Tonemapping_PQmask(&LCTmap);
	drvif_color_set_LC_Sharpness_PQmask(&LCSharp);

	// SRNN_TBD ?

	rtd_pr_vpq_info( "[%s] end\n", __FUNCTION__);
}

/**
 * @brief
 * get the internal structure pointer
 * @param InfoIndex
 * info index
 * @return void*
 * pointer to the specific structure
 */
void *scalerPQMaskColor_GetStruct(unsigned int InfoIndex) {
	void * RetPtr = NULL;
	switch(InfoIndex) {
		case PQMASK_COLORSTRUCT_MGR:
			RetPtr = (void *)&PQMaskColorMgr;
			break;
		case PQMASK_COLORSTRUCT_SEMATNIIC_HISTO:
			RetPtr = (void *)&PQMaskColorMgr.SemanticHist;
			break;
		case PQMASK_COLORSTRUCT_DEPTH_HISTO:
			RetPtr = (void *)&PQMaskColorMgr.DepthHist;
			break;
		case PQMASK_COLORSTRUCT_PALETTE:
			RetPtr = (void *)PQMaskPalette;
			break;
		default:
			rtd_pr_vpq_info( "[%s] index = %d error\n", __FUNCTION__, InfoIndex);
			RetPtr = NULL;
			break;
	}
	return RetPtr;
}

/**
 * @brief
 * get the internal structure pointer
 * @return void*
 * pointer to the specific structure
 */
void *scalerPQMaskColor_GetLockTable(void) {
	return (void *)&PQMaskTableLock;
}


/**
 * @brief
 * generate the semantic information histogram
 * Hypothesis
 * 		1. semantic information is 8 bit data, value range = 0~(PQMASK_MODULE_NUM-1)
 */
void scalerPQMaskColor_SemanticHistogram(void *pInput) {

	int px=0, py=0;
	int histIdx=0;
	unsigned char *pDat = (unsigned char *)pInput;

#if 0 // time measurement
	unsigned int t0=0, t1=0;
	t0 = drvif_Get_90k_Lo_clk();
#endif

	if( PQMaskColorMgr.SemanticHist.Info.enable == 0 )
		return;

	// error protection
	if( (PQMaskColorMgr.SemanticHist.Info.hJmp) == 0 || (PQMaskColorMgr.SemanticHist.Info.vJmp == 0) ) {
		rtd_pr_vpq_info( "[%s][%d] hJmp = %d, vJmp = %d, error",
			__FUNCTION__, __LINE__, PQMaskColorMgr.SemanticHist.Info.hJmp, PQMaskColorMgr.SemanticHist.Info.vJmp);
		return;
	}

	memset(&PQMaskColorMgr.SemanticHist.Data, 0, sizeof(PQMASK_HIST_DATA_T));

	for(py=0; py<(PQMaskColorMgr.SemanticHist.Info.height); py=py+(PQMaskColorMgr.SemanticHist.Info.vJmp)) {
		for(px=0; px<(PQMaskColorMgr.SemanticHist.Info.width); px=px+(PQMaskColorMgr.SemanticHist.Info.hJmp)) {
			histIdx = pDat[py*PQMaskColorMgr.SemanticHist.Info.width+px];
			if( histIdx < PQMASK_MODULE_NUM ) {
				PQMaskColorMgr.SemanticHist.Data.Histogram[histIdx]++;
				PQMaskColorMgr.SemanticHist.Data.TotalPts++;
			} else {
				// rtd_pr_vpq_info( "[%s][%d] index %d over maximum %d, error\n", __FUNCTION__, __LINE__, histIdx, PQMASK_MODULE_NUM);
			}
		}
	}

	PQMaskColorMgr.SemanticHist.Data.TotalPts = PQMaskColorMgr.SemanticHist.Data.TotalPts | 0x1;
	for(px=0; px<PQMASK_LABEL_NUM; px++) {
		PQMaskColorMgr.SemanticHist.Data.NorHist[px] = (((PQMaskColorMgr.SemanticHist.Data.Histogram[px]*1000)+500) / PQMaskColorMgr.SemanticHist.Data.TotalPts);
		PQMaskColorMgr.SemanticHist.Data.TotalPercent = PQMaskColorMgr.SemanticHist.Data.TotalPercent + PQMaskColorMgr.SemanticHist.Data.NorHist[px];
	}

#if 0 // time measurement
	t1 = drvif_Get_90k_Lo_clk();
	rtd_pr_vpq_info( "90k diff = %d\n", t1-t0);
#endif

#if 0 // debug log
	for(px=0; px<PQMASK_MODULE_NUM; px++) {
		rtd_pr_vpq_info( "[%3d] %4d/1000, %d\n", px, PQMaskColorMgr.SemanticHist.Data.NorHist[px], PQMaskColorMgr.SemanticHist.Data.Histogram[px]);
	}
	rtd_pr_vpq_info( "Total %d pts, Total %d percentage\n", PQMaskColorMgr.SemanticHist.Data.TotalPts, PQMaskColorMgr.SemanticHist.Data.TotalPercent);
#endif

}

/**
 * @brief 
 * generate the depth information histogram
 * Hypothesis : depth information is 8 bit data, value range is 0~255
 * @param pInput : the image buffer
 */
void scalerPQMaskColor_DepthHistogram(void *pInput) {

	int px=0, py=0;
	int histIdx=0;
	unsigned int AplSum = 0;
	unsigned int Histogram[PQMASK_HISTO_BIN] = {0};
	unsigned char *pDat = (unsigned char *)pInput;

#if 0 // time measurement
	unsigned int t0=0, t1=0;
	t0 = drvif_Get_90k_Lo_clk();
#endif

	// error protection
	if( (PQMaskColorMgr.DepthHist.Info.hJmp) == 0 || (PQMaskColorMgr.DepthHist.Info.vJmp == 0) ) {
		rtd_pr_vpq_info( "[%s][%d] hJmp = %d, vJmp = %d, error",
			__FUNCTION__, __LINE__, PQMaskColorMgr.DepthHist.Info.hJmp, PQMaskColorMgr.DepthHist.Info.vJmp);
		return;
	}

	PQMaskColorMgr.DepthHist.Data.TotalPts = 0;

	for(py=0; py<(PQMaskColorMgr.DepthHist.Info.height); py=py+(PQMaskColorMgr.DepthHist.Info.vJmp)) {
		for(px=0; px<(PQMaskColorMgr.DepthHist.Info.width); px=px+(PQMaskColorMgr.DepthHist.Info.hJmp)) {
			// histogram
			histIdx = pDat[py*PQMaskColorMgr.DepthHist.Info.width+px] >> (8-PQMASK_HISTO_BIN_SFT);
			if( histIdx < PQMASK_HISTO_BIN ) {
				Histogram[histIdx]++;
				PQMaskColorMgr.DepthHist.Data.TotalPts++;
			} else {
				rtd_pr_vpq_info( "[%s][%d] index %d over maximum %d, error\n", __FUNCTION__, __LINE__, histIdx, PQMASK_HISTO_BIN);
			}
			// apl
			AplSum = AplSum + pDat[py*PQMaskColorMgr.DepthHist.Info.width+px];
		}
	}

	// apl (align to 10 bits)
	if( PQMaskColorMgr.DepthHist.Data.TotalPts <= 0 ) 
		PQMaskColorMgr.DepthHist.Data.Apl = 0;
	else
		PQMaskColorMgr.DepthHist.Data.Apl = ((AplSum << 2) / PQMaskColorMgr.DepthHist.Data.TotalPts);

	PQMaskColorMgr.DepthHist.Data.TotalPts = PQMaskColorMgr.DepthHist.Data.TotalPts | 0x1;

	// histogram
	memcpy(&PQMaskColorMgr.DepthHist.Data.Histogram, Histogram, sizeof(unsigned int)*PQMASK_HISTO_BIN);
	PQMaskColorMgr.DepthHist.Data.TotalPercent = 0;
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		PQMaskColorMgr.DepthHist.Data.NorHist[px] = (((Histogram[px]*1000)+500) / PQMaskColorMgr.DepthHist.Data.TotalPts);
		PQMaskColorMgr.DepthHist.Data.TotalPercent = PQMaskColorMgr.DepthHist.Data.TotalPercent + PQMaskColorMgr.DepthHist.Data.NorHist[px];
	}	

#if 0 // time measurement
	t1 = drvif_Get_90k_Lo_clk();
	rtd_pr_vpq_info( "90k diff = %d\n", t1-t0);
#endif

#if 0 // debug log
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %4d/1000, %d\n", px, PQMaskColorMgr.DepthHist.Data.NorHist[px], PQMaskColorMgr.DepthHist.Data.Histogram[px]);
	}
	rtd_pr_vpq_info( "Total %d pts, Total %d percentage, APL = %d\n", PQMaskColorMgr.DepthHist.Data.TotalPts, PQMaskColorMgr.DepthHist.Data.TotalPercent, PQMaskColorMgr.DepthHist.Data.Apl);
#endif

}

/**
 * @brief
 * generate the image vs. depth information histogram
 * @param pImgInput : input data with NV12
 * @param pInfoInput : input depth information
 */
void scalerPQMaskColor_Img2DepthHistogram(void *pImgInput, void *pInfoInput) {

	int px=0, py=0;
	int sectionIdx = 0, histIdx=0;
	int yDatIdx = 0, uvDatIdx = 0;
	int yDat = 0, uDat = 0, vDat = 0;
	unsigned char *pDat = (unsigned char *)pInfoInput;
	unsigned char *pImg = (unsigned char *)pImgInput;

#if 0 // time measurement
	unsigned int t0=0, t1=0;
	t0 = drvif_Get_90k_Lo_clk();
#endif

	if( PQMaskColorMgr.ImgByDepthHistInfo.enable == 0 ) {
		return;
	}

	// error protection
	if( (PQMaskColorMgr.ImgByDepthHistInfo.hJmp) == 0 || (PQMaskColorMgr.ImgByDepthHistInfo.vJmp == 0) ) {
		rtd_pr_vpq_info( "[%s][%d] hJmp = %d, vJmp = %d, error",
			__FUNCTION__, __LINE__, PQMaskColorMgr.ImgByDepthHistInfo.hJmp, PQMaskColorMgr.ImgByDepthHistInfo.vJmp);
		return;
	}

	if( PQMaskColorMgr.ThlLow > PQMaskColorMgr.ThlHigh ) {
		rtd_pr_vpq_info( "[%s][%d] threshold error, low = %d, high = %d\n",
			__FUNCTION__, __LINE__, PQMaskColorMgr.ThlLow, PQMaskColorMgr.ThlHigh);
		return;
	}

	if( pImg == NULL ) {
		rtd_pr_vpq_info( "[%s][%d] depth src img not ready\n", __FUNCTION__, __LINE__);
		return;
	}

	memset(&PQMaskColorMgr.ImgByDepthHist, 0x0, PQMASK_DEPDIST_NUM*PQMASK_IMGCH_NUM*sizeof(PQMASK_HIST_T));

	for(py=0; py<AI_DEPTHMAP_HEIGHT; py=py+(PQMaskColorMgr.ImgByDepthHistInfo.vJmp)) {
		for(px=0; px<AI_DEPTHMAP_WIDTH; px=px+(PQMaskColorMgr.ImgByDepthHistInfo.hJmp)) {

			// depth data
			if( pDat[py*AI_DEPTHMAP_WIDTH+px] <= PQMaskColorMgr.ThlLow )
				sectionIdx = PQMASK_DEPDIST_FAR;
			else if( pDat[py*AI_DEPTHMAP_WIDTH+px] > PQMaskColorMgr.ThlLow && pDat[py*AI_DEPTHMAP_WIDTH+px] <= PQMaskColorMgr.ThlHigh )
				sectionIdx = PQMASK_DEPDIST_MID;
			else
				sectionIdx = PQMASK_DEPDIST_NEAR;

			// image data
			yDatIdx = py*AI_DEPTHMAP_WIDTH+px;
			uvDatIdx = (AI_DEPTHMAP_WIDTH*AI_DEPTHMAP_HEIGHT) + (py/2)*AI_DEPTHMAP_WIDTH + (px/2);
			yDat = pImg[yDatIdx];
			uDat = pImg[uvDatIdx+0];
			vDat = pImg[uvDatIdx+1];

			histIdx = yDat >> (8-PQMASK_HISTO_BIN_SFT);
			if( histIdx < PQMASK_HISTO_BIN) {
				PQMaskColorMgr.ImgByDepthHist[sectionIdx][PQMASK_IMGCH_Y].Data.Histogram[histIdx]++;
				PQMaskColorMgr.ImgByDepthHist[sectionIdx][PQMASK_IMGCH_Y].Data.TotalPts++;
			} else {
				rtd_pr_vpq_info( "[%s][%d] index %d over maximum %d, error\n", __FUNCTION__, __LINE__, histIdx, PQMASK_HISTO_BIN);
			}

			histIdx = uDat >> (8-PQMASK_HISTO_BIN_SFT);
			if( histIdx < PQMASK_HISTO_BIN) {
				PQMaskColorMgr.ImgByDepthHist[sectionIdx][PQMASK_IMGCH_U].Data.Histogram[histIdx]++;
				PQMaskColorMgr.ImgByDepthHist[sectionIdx][PQMASK_IMGCH_U].Data.TotalPts++;
			} else {
				rtd_pr_vpq_info( "[%s][%d] index %d over maximum %d, error\n", __FUNCTION__, __LINE__, histIdx, PQMASK_HISTO_BIN);
			}

			histIdx = vDat >> (8-PQMASK_HISTO_BIN_SFT);
			if( histIdx < PQMASK_HISTO_BIN) {
				PQMaskColorMgr.ImgByDepthHist[sectionIdx][PQMASK_IMGCH_V].Data.Histogram[histIdx]++;
				PQMaskColorMgr.ImgByDepthHist[sectionIdx][PQMASK_IMGCH_V].Data.TotalPts++;
			} else {
				rtd_pr_vpq_info( "[%s][%d] index %d over maximum %d, error\n", __FUNCTION__, __LINE__, histIdx, PQMASK_HISTO_BIN);
			}
		}
	}

#if 0 // time measurement
	t1 = drvif_Get_90k_Lo_clk();
	rtd_pr_vpq_info( "90k diff = %d\n", t1-t0);
#endif

#if 0 // debug log

	rtd_pr_vpq_info( "Threshold low = %d, high = %d\n", PQMaskColorMgr.ThlLow, PQMaskColorMgr.ThlHigh);

	rtd_pr_vpq_info( "FAR YCH\n");
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %d\n", px, PQMaskColorMgr.ImgByDepthHist[PQMASK_DEPDIST_FAR][PQMASK_IMGCH_Y].Data.Histogram[px]);
	}
	rtd_pr_vpq_info( "FAR UCH\n");
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %d\n", px, PQMaskColorMgr.ImgByDepthHist[PQMASK_DEPDIST_FAR][PQMASK_IMGCH_U].Data.Histogram[px]);
	}
	rtd_pr_vpq_info( "FAR VCH\n");
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %d\n", px, PQMaskColorMgr.ImgByDepthHist[PQMASK_DEPDIST_FAR][PQMASK_IMGCH_V].Data.Histogram[px]);
	}

	rtd_pr_vpq_info( "MID YCH\n");
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %d\n", px, PQMaskColorMgr.ImgByDepthHist[PQMASK_DEPDIST_MID][PQMASK_IMGCH_Y].Data.Histogram[px]);
	}
	rtd_pr_vpq_info( "MID UCH\n");
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %d\n", px, PQMaskColorMgr.ImgByDepthHist[PQMASK_DEPDIST_MID][PQMASK_IMGCH_U].Data.Histogram[px]);
	}
	rtd_pr_vpq_info( "MID VCH\n");
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %d\n", px, PQMaskColorMgr.ImgByDepthHist[PQMASK_DEPDIST_MID][PQMASK_IMGCH_V].Data.Histogram[px]);
	}

	rtd_pr_vpq_info( "NEAR YCH\n");
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %d\n", px, PQMaskColorMgr.ImgByDepthHist[PQMASK_DEPDIST_NEAR][PQMASK_IMGCH_Y].Data.Histogram[px]);
	}
	rtd_pr_vpq_info( "NEAR UCH\n");
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %d\n", px, PQMaskColorMgr.ImgByDepthHist[PQMASK_DEPDIST_NEAR][PQMASK_IMGCH_U].Data.Histogram[px]);
	}
	rtd_pr_vpq_info( "NEAR VCH\n");
	for(px=0; px<PQMASK_HISTO_BIN; px++) {
		rtd_pr_vpq_info( "[%3d] %d\n", px, PQMaskColorMgr.ImgByDepthHist[PQMASK_DEPDIST_NEAR][PQMASK_IMGCH_V].Data.Histogram[px]);
	}
#endif

}

/**
 * @brief
 * origanize the image by semantic label histogram information
 * statistic action is done by ap
 */
void scalerPQMaskColor_Img2SemanticHistogram(void) {

	int labels = 0, channel = 0, i=0;

#if 0 // time measurement
	unsigned int t0=0, t1=0;
	t0 = drvif_Get_90k_Lo_clk();
#endif

	if( PQMaskColorMgr.ImgBySemanticHist[0][0].Info.enable == 0 )
		return;

	for(labels=0; labels<PQMASK_LABEL_NUM; labels++) {
		for(channel=0; channel<PQMASK_IMGCH_NUM; channel++){
			PQMaskColorMgr.ImgBySemanticHist[labels][channel].Data.TotalPts = 0;
			for(i=0; i<PQMASK_HISTO_BIN; i++) {
				PQMaskColorMgr.ImgBySemanticHist[labels][channel].Data.TotalPts += PQMaskColorMgr.ImgBySemanticHist[labels][channel].Data.Histogram[i];
			}
		}
	}

#if 0 // time measurement
	t1 = drvif_Get_90k_Lo_clk();
	rtd_pr_vpq_info( "90k diff = %d\n", t1-t0);
#endif

}

/**
 * @brief
 * construct the semantic palette for se action
 * @param group
 * @param pPalette
 */
void scalerPQMaskColor_Label2Clut(unsigned int group, KGAL_PALETTE_INFO_T *pPalette) {

	pPalette->length = 256;
	pPalette->startpale = 0;
	if( group >= MODULE_GRP_MAX )
		group = 0;
	memcpy(pPalette->palette, PQMaskPalette[PQMASK_COLOR_PALETTE_SEMANTIC][group], sizeof(unsigned int)*PQMASK_LABEL_NUM);

#if 0
	rtd_pr_vpq_info( "[%s] clut trans module [%-*s] [%-*s] [%-*s]\n",
		__FUNCTION__,
		PQMASK_STRING_LEN, PQMaskModuleName[idx1],
		PQMASK_STRING_LEN, PQMaskModuleName[idx2],
		PQMASK_STRING_LEN, PQMaskModuleName[idx3]
	);
#endif
#if 0
	for(i=0; i<(256/4); i++) {
		rtd_pr_vpq_info( "[%3d] 0x%08x [%3d] 0x%08x [%3d] 0x%08x [%3d] 0x%08x\n",
			(i*4)+0, pPalette->palette[(i*4)+0],
			(i*4)+1, pPalette->palette[(i*4)+1],
			(i*4)+2, pPalette->palette[(i*4)+2],
			(i*4)+3, pPalette->palette[(i*4)+3]
		);
	}
#endif

}

/**
 * @brief
 * construct the depth palette for se action
 * @param group
 * @param pPalette
 */
void scalerPQMaskColor_Depth2Clut(unsigned int group, KGAL_PALETTE_INFO_T *pPalette) {

	pPalette->length = 256;
	pPalette->startpale = 0;
	if( group >= MODULE_GRP_MAX )
		group = 0;
	memcpy(pPalette->palette, PQMaskPalette[PQMASK_COLOR_PALETTE_DEPTH][group], sizeof(unsigned int)*PQMASK_MAPCURVE_LEN);

#if 0
	rtd_pr_vpq_info( "[%s] clut trans module [%-*s] [%-*s] [%-*s]\n",
		__FUNCTION__,
		PQMASK_STRING_LEN, PQMaskModuleName[idx1],
		PQMASK_STRING_LEN, PQMaskModuleName[idx2],
		PQMASK_STRING_LEN, PQMaskModuleName[idx3]
	);
#endif
#if 0
	for(i=0; i<(256/4); i++) {
		rtd_pr_vpq_info( "[%3d] 0x%08x [%3d] 0x%08x [%3d] 0x%08x [%3d] 0x%08x\n",
			(i*4)+0, pPalette->palette[(i*4)+0],
			(i*4)+1, pPalette->palette[(i*4)+1],
			(i*4)+2, pPalette->palette[(i*4)+2],
			(i*4)+3, pPalette->palette[(i*4)+3]
		);
	}
#endif

}

/**
 * @brief
 * construct the defocus palette for se action
 * @param group
 * @param pPalette
 */
void scalerPQMaskColor_Defocus2Clut(unsigned int group, KGAL_PALETTE_INFO_T *pPalette) {

	pPalette->length = 256;
	pPalette->startpale = 0;
	if( group >= MODULE_GRP_MAX )
		group = 0;
	memcpy(pPalette->palette, PQMaskPalette[PQMASK_COLOR_PALETTE_DEFOCUS][group], sizeof(unsigned int)*PQMASK_MAPCURVE_LEN);

#if 0
	rtd_pr_vpq_info( "[%s] clut trans module [%-*s] [%-*s] [%-*s]\n",
		__FUNCTION__,
		PQMASK_STRING_LEN, PQMaskModuleName[idx1],
		PQMASK_STRING_LEN, PQMaskModuleName[idx2],
		PQMASK_STRING_LEN, PQMaskModuleName[idx3]
	);
#endif
#if 0
	for(i=0; i<(256/4); i++) {
		rtd_pr_vpq_info( "[%3d] 0x%08x [%3d] 0x%08x [%3d] 0x%08x [%3d] 0x%08x\n",
			(i*4)+0, pPalette->palette[(i*4)+0],
			(i*4)+1, pPalette->palette[(i*4)+1],
			(i*4)+2, pPalette->palette[(i*4)+2],
			(i*4)+3, pPalette->palette[(i*4)+3]
		);
	}
#endif

}

/**
 * @brief
 * Make the scene change flag
 */
void scalerPQMaskColor_SceneChange(void) {

	_clues *SmartPic_clue = NULL;
	_RPC_clues *RPC_SmartPic_clue = NULL;

	SmartPic_clue = fwif_color_Get_SmartPic_clue();
	RPC_SmartPic_clue = (_RPC_clues *)Scaler_GetShareMemVirAddr(SCALERIOC_VIP_RPC_SMARTPIC_CLUS);

	if( PQMaskColorMgr.Param.bSceneChangeEnable != 0 ) {
		PQMaskColorMgr.Status.bSceneChange = PQMaskColorMgr.Status.bSceneChange | SmartPic_clue->SceneChange_by_diff_mean_Dev | RPC_SmartPic_clue->SceneChange;
#if 0
		if(PQMaskColorMgr.Status.bSceneChange != 0) {
			rtd_pr_vpq_info( "[%s] scene change happen\n", __FUNCTION__);
		}
#endif
	} else {
		PQMaskColorMgr.Status.bSceneChange = 0;
	}
}

/**
 * @brief
 * Get the genre information from ai model
 */
void scalerPQMaskColor_GetGenre(void) {

	int CurrentGenre = drvif_color_get_Genre_info();

	if( PQMaskColorMgr.Param.bGenre_CG_Enable != 0 ) {
		if( CurrentGenre == AI_GENRE_PATTERN ) {
			if( PQMaskColorMgr.Status.AiGenre != AI_GENRE_PATTERN ) {
				PQMaskColorMgr.Status.bGenerCGStatusChange = 1;
				PQMaskColorMgr.Status.bReloadDepthPalette_AiGenre_CG = 1;
				PQMaskColorMgr.Status.bReloadSemanticPalette_AiGenre_CG= 1;
				PQMaskColorMgr.Status.bReloadDefocusPalette_AiGenre_CG= 1;
				rtd_pr_vpq_info( "[%s] enter cg pattern\n", __FUNCTION__);
			}
		} else {
			if( PQMaskColorMgr.Status.AiGenre == AI_GENRE_PATTERN ) {
				PQMaskColorMgr.Status.bGenerCGStatusChange = 1;
				scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEPTH);
				scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_SEMANTIC);
				scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEFOCUS);
				rtd_pr_vpq_info( "[%s] leave cg pattern\n", __FUNCTION__);
			}
		}
		PQMaskColorMgr.Status.AiGenre = CurrentGenre;
	} else {
		PQMaskColorMgr.Status.AiGenre = AI_GENRE_TYPE_NUM;
	}
}

/**
 * @brief
 * Force se output current result only
 * @param Frames
 * times
 */
void scalerPQMaskColor_ForceOutputCur(unsigned char Frames) {
	rtd_pr_vpq_info( "[%s] start, frame = %d\n", __FUNCTION__, Frames);
	PQMaskColorMgr.Status.ForceCurFrm = Frames;
	rtd_pr_vpq_info( "[%s] done\n", __FUNCTION__);
}

/**
 * @brief
 * return  XXXRstWeight for semantic by idx
 * @param ModuleIdx
 */
unsigned char scalerPQMaskColor_getSemanticRstWeightByModule(unsigned char ModuleIdx) {
	unsigned char RstWeight = 128;
	if (ModuleIdx == PQMASK_MODULE_LC){
		RstWeight = PQMaskColorMgr.Status.LocalContrastRstWeight;
	}
	else if (ModuleIdx >= PQMASK_MODULE_SRNN_IN_0 && ModuleIdx <= PQMASK_MODULE_SRNN_IN_2){
		RstWeight = PQMaskColorMgr.Status.SrnnInRstWeight;
	}
	else if (ModuleIdx == PQMASK_MODULE_SRNN_OUT_0){
		RstWeight = PQMaskColorMgr.Status.SrnnOutRstWeight;
	}
	else{
		RstWeight = 128;
	}

	return RstWeight;
}



/**
 * @brief
 * prepare the palette for se action
 */
void scalerPQMaskColor_ConstructPalette(void) {

	int i=0, group=0, tmpValue=0, delta=0, sqm_en=0;
	int idx0=0, idx1=0, idx2=0;
	unsigned char ChannelA=0, ChannelR=0, ChannelG=0, ChannelB=0;
	int ActualTmapBld=0;
	int RemapLocalContrastWeight[PQMASK_MAPCURVE_LEN];
	DRV_LC_ToneMapping_Blend TmapBld;
	int PQMaskWeightTbl_SQM[PQMASK_MODULE_NUM] = {0};
	int ai_resolution_cur = 0;
	static int ai_resolution_pre = 0;
	extern int ai_resolution;
	extern RTK_AI_PQ_mode aipq_mode;
	extern VIP_SRNN_SQM_INFO gSrnnSQMInfo;
	//extern short AI_PQMaskWeightTbl_SQM_TBL[AI_RESOLUTION_TYPE_NUM][PQMASK_MODULE_NUM];

	if (gSrnnSQMInfo.SQMFlowEn == 1){
		ai_resolution_cur = ai_resolution+gSrnnSQMInfo.DebugPosOffset-gSrnnSQMInfo.DebugNegOffset;
		if (ai_resolution_cur < 0 || ai_resolution_cur >= AI_RESOLUTION_TYPE_NUM){
			ai_resolution_cur = ai_resolution;
		}
	}
	else{
		ai_resolution_cur = ai_resolution;
	}
	
	for(i=0; i<PQMASK_MODULE_NUM; i++) {
		PQMaskWeightTbl_SQM[i] = AI_PQMaskWeightTbl_SQM_TBL[ai_resolution_cur][i];
	}
	sqm_en = !!aipq_mode.sqm_mode;

	if (ai_resolution_cur != ai_resolution_pre) {
		PQMaskColorMgr.Status.bReloadDepPalette = 1; //update SQM diff
		PQMaskColorMgr.Status.bReloadSemPalette = 1; //update SQM diff
		PQMaskColorMgr.Status.bReloadDefocusPalette= 1; //update SQM diff
		ai_resolution_pre = ai_resolution_cur;
	}

	// rtd_pr_vpq_info( "[%s] start\n", __FUNCTION__);

	// TODO : waste computing power
	// calibrate the local contrast weight dc to 128
	drvif_color_get_LC_ToneMapping_Blend(&TmapBld);
	ActualTmapBld = (TmapBld.lc_tmap_blend_factor > 128) ? 128 : TmapBld.lc_tmap_blend_factor;
	PQMaskColorMgr.Status.LocalContrastRstWeight = ActualTmapBld*2;
	if( PQMaskColorMgr.Status.LocalContrastRstWeight > 255 )
		PQMaskColorMgr.Status.LocalContrastRstWeight = 255;

	// depth palette
	if( PQMaskColorMgr.Status.AiGenre == AI_GENRE_PATTERN ) {
		if( PQMaskColorMgr.Status.bReloadDepthPalette_AiGenre_CG != 0 ) {

			rtd_pr_vpq_info( "[%s] update depth palette for CG start\n", __FUNCTION__);

			// fill in the BYPASS mapping curve
			for(group=0; group<MODULE_GRP_MAX; group++) {

				idx0 = (SEProcGrpMapping[group][0] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][0];
				idx1 = (SEProcGrpMapping[group][1] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][1];
				idx2 = (SEProcGrpMapping[group][2] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][2];

				for(i=0; i<PQMASK_MAPCURVE_LEN; i++) {
					ChannelA = 0;
					ChannelR = (idx0==PQMASK_MODULE_LC)? PQMaskColorMgr.Status.LocalContrastRstWeight : 128;
					ChannelG = (idx1==PQMASK_MODULE_LC)? PQMaskColorMgr.Status.LocalContrastRstWeight : 128;
					ChannelB = (idx2==PQMASK_MODULE_LC)? PQMaskColorMgr.Status.LocalContrastRstWeight : 128;

					PQMaskPalette[PQMASK_COLOR_PALETTE_DEPTH][group][i] = (ChannelA<<24) + (ChannelR<<16) + (ChannelG<<8) + ChannelB;
				}
			}

			PQMaskColorMgr.Status.bReloadDepthPalette_AiGenre_CG = 0;

			rtd_pr_vpq_info( "[%s] update depth palette for CG done\n", __FUNCTION__);
		}
	} else {
		
		if( PQMaskColorMgr.Status.bReloadDepPalette != 0 ) {

			rtd_pr_vpq_info( "[%s] update depth palette start\n", __FUNCTION__);

			if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEPTH) != 0 ) {

				// local contrast mapping curve
				memset(RemapLocalContrastWeight, 0x0, sizeof(int)*PQMASK_MAPCURVE_LEN);
				delta = sqm_en*PQMaskWeightTbl_SQM[PQMASK_MODULE_LC];
				for( i=0; i<PQMASK_MAPCURVE_LEN; i++ ) {
					tmpValue = PQMaskColorMgr.DepthWeightTbl[PQMASK_MODULE_LC][i]+delta;
					tmpValue = CLAMP(tmpValue, 0, 255);
					RemapLocalContrastWeight[i] = (tmpValue-128) + PQMaskColorMgr.Status.LocalContrastRstWeight;
					if( RemapLocalContrastWeight[i] > 255 )
						RemapLocalContrastWeight[i] = 255;
					if( RemapLocalContrastWeight[i] < 0 )
						RemapLocalContrastWeight[i] = 0;
				}

				// fill in the mapping curve
				for(group=0; group<MODULE_GRP_MAX; group++) {

					idx0 = (SEProcGrpMapping[group][0] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][0];
					idx1 = (SEProcGrpMapping[group][1] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][1];
					idx2 = (SEProcGrpMapping[group][2] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][2];

					for(i=0; i<PQMASK_MAPCURVE_LEN; i++) {

						ChannelA = 0;
						tmpValue = PQMaskColorMgr.DepthWeightTbl[idx0][i]+(PQMaskWeightTbl_SQM[idx0]*sqm_en);
						ChannelR = (idx0==PQMASK_MODULE_LC)? RemapLocalContrastWeight[i] : CLAMP(tmpValue, 0, 255);
						tmpValue = PQMaskColorMgr.DepthWeightTbl[idx1][i]+(PQMaskWeightTbl_SQM[idx1]*sqm_en);
						ChannelG = (idx1==PQMASK_MODULE_LC)? RemapLocalContrastWeight[i] : CLAMP(tmpValue, 0, 255);
						tmpValue = PQMaskColorMgr.DepthWeightTbl[idx2][i]+(PQMaskWeightTbl_SQM[idx2]*sqm_en);
						ChannelB = (idx2==PQMASK_MODULE_LC)? RemapLocalContrastWeight[i] : CLAMP(tmpValue, 0, 255);
	
						PQMaskPalette[PQMASK_COLOR_PALETTE_DEPTH][group][i] = (ChannelA<<24) + (ChannelR<<16) + (ChannelG<<8) + ChannelB;

					}

				}

	#if 0
				rtd_pr_vpq_info( "Depth palette\n");
				for( group=0; group<MODULE_GRP_MAX; group++ ) {
					for( i=0; i<PQMASK_MAPCURVE_LEN; i++ ) {
						rtd_pr_vpq_info( "[%1d][%3d] 0x%08x\n", group, i, PQMaskPalette[PQMASK_COLOR_PALETTE_DEPTH][group][i]);
					}
				}
	#endif

				PQMaskColorMgr.Status.bReloadDepPalette = 0;
				scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEPTH);
			} else {
				rtd_pr_vpq_info( "[%s] lock depth table fail\n", __FUNCTION__);
			}

			rtd_pr_vpq_info( "[%s] update depth palette done\n", __FUNCTION__);

		}
	}

	// semantic palette
	if( PQMaskColorMgr.Status.AiGenre == AI_GENRE_PATTERN ) {

		if( PQMaskColorMgr.Status.bReloadSemanticPalette_AiGenre_CG != 0 ) {

			rtd_pr_vpq_info( "[%s] update semantic palette for CG start\n", __FUNCTION__);

			// fill in the BYPASS mapping curve
			for(group=0; group<MODULE_GRP_MAX; group++) {

				idx0 = (SEProcGrpMapping[group][0] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][0];
				idx1 = (SEProcGrpMapping[group][1] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][1];
				idx2 = (SEProcGrpMapping[group][2] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][2];

				for(i=0; i<PQMASK_LABEL_NUM; i++) {

					ChannelA = 0;
					ChannelR = scalerPQMaskColor_getSemanticRstWeightByModule(idx0);
					ChannelG = scalerPQMaskColor_getSemanticRstWeightByModule(idx1);
					ChannelB = scalerPQMaskColor_getSemanticRstWeightByModule(idx2);

					PQMaskPalette[PQMASK_COLOR_PALETTE_SEMANTIC][group][i] = (ChannelA<<24) + (ChannelR<<16) + (ChannelG<<8) + ChannelB;

				}

			}

			PQMaskColorMgr.Status.bReloadSemanticPalette_AiGenre_CG = 0;

			rtd_pr_vpq_info( "[%s] update semantic palette for CG done\n", __FUNCTION__);

		}

	} else {
		if( PQMaskColorMgr.Status.bReloadSemPalette != 0 ) {

		rtd_pr_vpq_info( "[%s] update semantic palette start\n", __FUNCTION__);

		if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_SEMANTIC) != 0 ) {

			// local contrast mapping curve
			memset(RemapLocalContrastWeight, 0x0, sizeof(int)*PQMASK_MAPCURVE_LEN);
			delta = sqm_en*PQMaskWeightTbl_SQM[PQMASK_MODULE_LC];
			for( i=0; i<PQMASK_LABEL_NUM; i++ ) {
				tmpValue = PQMaskColorMgr.SemanticWeightTbl[PQMASK_MODULE_LC][i]+delta;
				tmpValue = CLAMP(tmpValue, 0, 255);
				RemapLocalContrastWeight[i] = (tmpValue-128) + PQMaskColorMgr.Status.LocalContrastRstWeight;
				if( RemapLocalContrastWeight[i] > 255 )
					RemapLocalContrastWeight[i] = 255;
				if( RemapLocalContrastWeight[i] < 0 )
					RemapLocalContrastWeight[i] = 0;
			}

			// fill in the mapping curve
			for(group=0; group<MODULE_GRP_MAX; group++) {

				idx0 = (SEProcGrpMapping[group][0] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][0];
				idx1 = (SEProcGrpMapping[group][1] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][1];
				idx2 = (SEProcGrpMapping[group][2] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][2];

				for(i=0; i<PQMASK_LABEL_NUM; i++) {

					ChannelA = 0;
					tmpValue = PQMaskColorMgr.SemanticWeightTbl[idx0][i]+(PQMaskWeightTbl_SQM[idx0]*sqm_en);
					ChannelR = (idx0==PQMASK_MODULE_LC)? RemapLocalContrastWeight[i] : CLAMP(tmpValue, 0, 255);
					tmpValue = PQMaskColorMgr.SemanticWeightTbl[idx1][i]+(PQMaskWeightTbl_SQM[idx1]*sqm_en);
					ChannelG = (idx1==PQMASK_MODULE_LC)? RemapLocalContrastWeight[i] : CLAMP(tmpValue, 0, 255);
					tmpValue = PQMaskColorMgr.SemanticWeightTbl[idx2][i]+(PQMaskWeightTbl_SQM[idx2]*sqm_en);
					ChannelB = (idx2==PQMASK_MODULE_LC)? RemapLocalContrastWeight[i] : CLAMP(tmpValue, 0, 255);

					PQMaskPalette[PQMASK_COLOR_PALETTE_SEMANTIC][group][i] = (ChannelA<<24) + (ChannelR<<16) + (ChannelG<<8) + ChannelB;

				}

			}

#if 0
			rtd_pr_vpq_info( "Semantic palette\n");
			for( group=0; group<MODULE_GRP_MAX; group++ ) {
				for( i=0; i<PQMASK_LABEL_NUM; i++ ) {
					rtd_pr_vpq_info( "[%1d][%3d] 0x%08x\n", group, i, PQMaskPalette[PQMASK_COLOR_PALETTE_SEMANTIC][group][i]);
				}
			}
#endif

			PQMaskColorMgr.Status.bReloadSemPalette = 0;
			scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_SEMANTIC);
		} else {
			rtd_pr_vpq_info( "[%s] lock semantic table fail\n", __FUNCTION__);
		}

		rtd_pr_vpq_info( "[%s] update semantic palette done\n", __FUNCTION__);

	}		
	}
	// rtd_pr_vpq_info( "[%s] done\n", __FUNCTION__);

	// defocus palette
	if( PQMaskColorMgr.Status.AiGenre == AI_GENRE_PATTERN ) {

		if( PQMaskColorMgr.Status.bReloadDefocusPalette_AiGenre_CG != 0 ) {

			rtd_pr_vpq_info( "[%s] update defocus palette for CG start\n", __FUNCTION__);

			// fill in the BYPASS mapping curve
			for(group=0; group<MODULE_GRP_MAX; group++) {

				idx0 = (SEProcGrpMapping[group][0] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][0];
				idx1 = (SEProcGrpMapping[group][1] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][1];
				idx2 = (SEProcGrpMapping[group][2] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][2];

				for(i=0; i<PQMASK_MAPCURVE_LEN; i++) {

					ChannelA = 0;
					ChannelR = (idx0==PQMASK_MODULE_LC)? PQMaskColorMgr.Status.LocalContrastRstWeight : 255;
					ChannelG = (idx1==PQMASK_MODULE_LC)? PQMaskColorMgr.Status.LocalContrastRstWeight : 255;
					ChannelB = (idx2==PQMASK_MODULE_LC)? PQMaskColorMgr.Status.LocalContrastRstWeight : 255;

					PQMaskPalette[PQMASK_COLOR_PALETTE_DEFOCUS][group][i] = (ChannelA<<24) + (ChannelR<<16) + (ChannelG<<8) + ChannelB;
				}
			}

			PQMaskColorMgr.Status.bReloadDefocusPalette_AiGenre_CG = 0;

			rtd_pr_vpq_info( "[%s] update defocus palette for CG done\n", __FUNCTION__);

		}

	} else {
		if( PQMaskColorMgr.Status.bReloadDefocusPalette != 0 ) {

		rtd_pr_vpq_info( "[%s] update defocus palette start\n", __FUNCTION__);

		if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEFOCUS) != 0 ) {
			//Defocus , weight refer to 0~1 gain instead of blending, 255 = *1.0
			// local contrast mapping curve
			memset(RemapLocalContrastWeight, 0xff, sizeof(int)*PQMASK_MAPCURVE_LEN);

			// fill in the mapping curve
			for(group=0; group<MODULE_GRP_MAX; group++) {

				idx0 = (SEProcGrpMapping[group][0] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][0];
				idx1 = (SEProcGrpMapping[group][1] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][1];
				idx2 = (SEProcGrpMapping[group][2] >= PQMASK_MODULE_NUM)? PQMASK_MODULE_NR : SEProcGrpMapping[group][2];

				for(i=0; i<PQMASK_MAPCURVE_LEN; i++) {
					ChannelA = 0;
					ChannelR = (idx0==PQMASK_MODULE_LC)? RemapLocalContrastWeight[i] : PQMaskColorMgr.DefocusWeightTbl[idx0][i];
					ChannelG = (idx1==PQMASK_MODULE_LC)? RemapLocalContrastWeight[i] : PQMaskColorMgr.DefocusWeightTbl[idx1][i];
					ChannelB = (idx2==PQMASK_MODULE_LC)? RemapLocalContrastWeight[i] : PQMaskColorMgr.DefocusWeightTbl[idx2][i];

					PQMaskPalette[PQMASK_COLOR_PALETTE_DEFOCUS][group][i] = (ChannelA<<24) + (ChannelR<<16) + (ChannelG<<8) + ChannelB;

				}

			}

#if 0
			rtd_pr_vpq_info( "Semantic palette\n");
			for( group=0; group<MODULE_GRP_MAX; group++ ) {
				for( i=0; i<PQMASK_LABEL_NUM; i++ ) {
					rtd_pr_vpq_info( "[%1d][%3d] 0x%08x\n", group, i, PQMaskPalette[PQMASK_COLOR_PALETTE_SEMANTIC][group][i]);
				}
			}
#endif

			PQMaskColorMgr.Status.bReloadDefocusPalette = 0;
			scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEFOCUS);
		} else {
			rtd_pr_vpq_info( "[%s] lock defocus table fail\n", __FUNCTION__);
		}

		rtd_pr_vpq_info( "[%s] update defocus palette done\n", __FUNCTION__);

	}		
	}
	// rtd_pr_vpq_info( "[%s] done\n", __FUNCTION__);
}

/**
 * @brief
 * trigger reload the palette for se
 * @param PaletteSel
 * select which palette to reload
 */
void scalerPQMaskColor_SetReloadPalette(unsigned char PaletteSel) {

	//rtd_pr_vpq_info( "[%s] start, set palette %d\n", __FUNCTION__, PaletteSel);

	switch(PaletteSel) {
		case PQMASK_COLOR_PALETTE_DEPTH:
			PQMaskColorMgr.Status.bReloadDepPalette = 1;
			break;
		case PQMASK_COLOR_PALETTE_SEMANTIC:
			PQMaskColorMgr.Status.bReloadSemPalette = 1;
			break;
		case PQMASK_COLOR_PALETTE_DEFOCUS:
			PQMaskColorMgr.Status.bReloadDefocusPalette = 1;
			break;
		default:
			rtd_pr_vpq_info( "index error\n");
			break;
	}

	//rtd_pr_vpq_info( "[%s] done\n", __FUNCTION__);

}

/**
 * @brief
 * adjust the label peaking related reigster to align sharpness pqmask weighting 128 = bypass
 */
void scalerPQMaskColor_UpdateLabelPK(void) {

	static DRV_Sharpness_Table ShpCurSetting;
	DRV_LABEL_PK ShpLabelPkSetting;
	int i=0;
	int dividen=256;
	int sobelRatio=1;
	int zdiffRatio=1;
	int textRatio=1;

	rtd_pr_vpq_info( "[%s] start\n", __FUNCTION__);

	drvif_color_Get_Sharpness_Table(&ShpCurSetting);

	memcpy(&ShpLabelPkSetting, &PQMaskColorMgr.ModuleSetting.Sharpness, sizeof(DRV_LABEL_PK));

	// Sobel
	if( PQMaskColorMgr.ModuleSetting.Sharpness.SobelUpbnd[4] == 0 ) {
		sobelRatio = dividen;
	} else {
		sobelRatio = (ShpCurSetting.TwoD_Peak_AdaptCtrl.Sobel_Upbnd*dividen)/PQMaskColorMgr.ModuleSetting.Sharpness.SobelUpbnd[4];
	}
	// Zdiff
	if( PQMaskColorMgr.ModuleSetting.Sharpness.ZDiffUpbnd[4] == 0 ) {
		zdiffRatio = dividen;
	} else {
		zdiffRatio = (ShpCurSetting.TwoD_Peak_AdaptCtrl.Zdiff_Upbnd*dividen)/PQMaskColorMgr.ModuleSetting.Sharpness.ZDiffUpbnd[4];
	}
	// Texture
	if( PQMaskColorMgr.ModuleSetting.Sharpness.TextUpbnd[4] == 0 ) {
		textRatio = dividen;
	} else {
		textRatio = (ShpCurSetting.TwoD_Peak_AdaptCtrl.Tex_Upbnd*dividen)/PQMaskColorMgr.ModuleSetting.Sharpness.TextUpbnd[4];
	}

	// rtd_printk(KERN_EMERG, "DEBUG", "[%s] ratio sobel = %d, zdiff = %d, text = %d\n", __FUNCTION__, sobelRatio, zdiffRatio, textRatio);

	for(i=0; i<9; i++) {
		ShpLabelPkSetting.SobelUpbnd[i] = (PQMaskColorMgr.ModuleSetting.Sharpness.SobelUpbnd[i]*sobelRatio + (dividen >> 1))/dividen;
		if( ShpLabelPkSetting.SobelUpbnd[i] > 255 )
			ShpLabelPkSetting.SobelUpbnd[i] = 255;
		ShpLabelPkSetting.ZDiffUpbnd[i] = (PQMaskColorMgr.ModuleSetting.Sharpness.ZDiffUpbnd[i]*zdiffRatio + (dividen >> 1))/dividen;
		if( ShpLabelPkSetting.ZDiffUpbnd[i] > 255 )
			ShpLabelPkSetting.ZDiffUpbnd[i] = 255;
		ShpLabelPkSetting.TextUpbnd[i] = (PQMaskColorMgr.ModuleSetting.Sharpness.TextUpbnd[i]*textRatio + (dividen >> 1))/dividen;
		if( ShpLabelPkSetting.TextUpbnd[i] > 255 )
			ShpLabelPkSetting.TextUpbnd[i] = 255;

		// rtd_printk(KERN_EMERG, "DEBUG", "[%s][%d] sobel = %3u, zdiff = %3u, text = %3u\n",
		// 	__FUNCTION__, i,
		// 	ShpLabelPkSetting.SobelUpbnd[i],
		// 	ShpLabelPkSetting.ZDiffUpbnd[i],
		// 	ShpLabelPkSetting.TextUpbnd[i]
		// );
	}

	drvif_set_labelpk(&ShpLabelPkSetting);

	rtd_pr_vpq_info( "[%s] end\n", __FUNCTION__);
}

/**
 * @brief 
 * to operate on curve, need to lock first
 * note. not support used in hard/woft irq
 * @param TableSel 
 * depth or semantic curve
 * @return int 
 * lock result, return non-zero if lock ok
 */
int scalerPQMaskColor_LockTable(unsigned char TableSel) {

	if( TableSel >= PQMASK_COLOR_PALETTE_MAX ) {
		rtd_pr_vpq_info( "[%s] TableSel = %d error\n", __FUNCTION__, TableSel);
		return 0;
	}

	if( PQMaskTableLock[TableSel].bIsInit == 0 ) {
		return 0;
	} else {
		spin_lock(&PQMaskTableLock[TableSel].CurveLock);
		return 1;
	}

	return 0;

}

/**
 * @brief 
 * finist operate on curve, need to lock first
 * note. not support used in hard/woft irq
 * @param TableSel 
 * depth or semantic curve
 * @return int 
 * lock result, return non-zero if lock ok
 */
int scalerPQMaskColor_UnLockTable(unsigned char TableSel) {

	if( TableSel >= PQMASK_COLOR_PALETTE_MAX ) {
		rtd_pr_vpq_info( "[%s] TableSel = %d error\n", __FUNCTION__, TableSel);
		return 0;
	}

	if( PQMaskTableLock[TableSel].bIsInit == 0 ) {
		return 0;
	} else {
		spin_unlock(&PQMaskTableLock[TableSel].CurveLock);
		return 1;
	}

	return 0;

}



// RTICE commands
void scalerPQMaskColor_GetSemanticWeight(unsigned char *Buf) {
	int i=0, j=0;
	for(i=0; i<PQMASK_MODULE_NUM; i++) {
		for(j=0; j<PQMASK_LABEL_NUM; j++) {
			Buf[i*PQMASK_LABEL_NUM + j] = PQMaskColorMgr.SemanticWeightTbl[i][j];
		}
	}
}

void scalerPQMaskColor_SetSemanticWeight(unsigned char *Buf) {
	int i=0, j=0;
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_SEMANTIC) != 0 ) {
		for(i=0; i<PQMASK_MODULE_NUM; i++) {
			for(j=0; j<PQMASK_LABEL_NUM; j++) {
				PQMaskColorMgr.SemanticWeightTbl[i][j] = Buf[i*PQMASK_LABEL_NUM + j];
			}
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_SEMANTIC);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_SEMANTIC);
	}
}
//convert 32 to 256
void scalerPQMaskColor_Convert_srnn_depth_weight_curve_map(unsigned char *depth_weight_in, unsigned char *depth_weight_out)
{
	int i, j, idx, diff, base;
	for (i = 0; i < DEPTH_SRNN_LABEL_NUM-1; i++)
	{
		diff = depth_weight_in[i+1] - depth_weight_in[i];
		base = depth_weight_in[i] * 8;
		idx = i*8;
		for (j = 0;j < 8; j++) {
			depth_weight_out[idx+j] = (base+diff*j)>>3;
		}
	}
	depth_weight_out[PQMASK_MAPCURVE_LEN-2] = depth_weight_out[PQMASK_MAPCURVE_LEN-1] = depth_weight_in[DEPTH_SRNN_LABEL_NUM-1];
}

void scalerPQMaskColor_GetDefocusWeight(unsigned char *Buf) {
	int i=0;
	for(i=0; i<PQMASK_MODULE_NUM; i++) {
		memcpy((void *)(Buf+i*PQMASK_MAPCURVE_LEN), (void *)PQMaskColorMgr.DefocusWeightTbl[i], sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
	}
}

void scalerPQMaskColor_SetDefocusWeight(unsigned char *Buf) {
	int i=0;
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEFOCUS) != 0 ) {
		for(i=0; i<PQMASK_MODULE_NUM; i++) {
			memcpy((void *)PQMaskColorMgr.DefocusWeightTbl[i], (void *)(Buf+i*PQMASK_MAPCURVE_LEN), sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEFOCUS);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEFOCUS);
	}
}

/**
 * @brief 
 * get defocus mapping curve
 * @param Buf 
 * @return Module 
 * Module == 0, SRNN IN0
 * Module == 1, SRNN IN1
 * Module == 2, SRNN IN2
 * Module == 3, SRNN OUT
 */
void scalerPQMaskColor_GetDefocusWeight_SRNN(unsigned char *Buf, unsigned char Module) {
	//int i=0;
	/*
	for(i=PQMASK_WEIGHT_SRNN_IN_0; i<PQMASK_WEIGHT_SRNN_MAX; i++) {
		memcpy((void *)(Buf+i*PQMASK_MAPCURVE_LEN), (void *)PQMaskColorMgr.DefocusWeightTbl[PQMASK_MODULE_SRNN_IN_0+i], sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
	}
	*/
	memcpy((void *)(Buf), (void *)PQMaskColorMgr.DefocusWeightTbl[PQMASK_MODULE_SRNN_IN_0+Module], sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
}


void scalerPQMaskColor_SetDefocusWeight_SRNN(unsigned char *Buf) {
#if 0
	int j=0, k=0;

	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEFOCUS) != 0 || PQMaskTableLock[PQMASK_COLOR_PALETTE_DEFOCUS].bIsInit == 0) {	//if pqmask is not init, set table directly
		// interp 256 points using 32 points
		// Defocus TBD, android srnn.bin should be 33 points insteads of 32 points
		for (j=0; j<(DEPTH_SRNN_LABEL_NUM-1); j++){
			if (j != DEPTH_SRNN_LABEL_NUM-2){
				for (k=0; k<8; k++){
					if (k == 0){
						PQMaskColorMgr.DefocusWeightTbl[PQMASK_MODULE_SRNN_IN_0+Module][j*8] = Buf[j];
					}
					else{
						PQMaskColorMgr.DefocusWeightTbl[PQMASK_MODULE_SRNN_IN_0+Module][j*8+k] = (Buf[j]*(8-k) + Buf[j+1]*k + 4) >> 3;
					}
				}
			}
			else{
				// last two points need interp 16 points (32 points limitation)
				for (k=0; k<16; k++){
					if (k == 0){
						PQMaskColorMgr.DefocusWeightTbl[PQMASK_MODULE_SRNN_IN_0+Module][j*8] = Buf[j];
					}
					else{
						PQMaskColorMgr.DefocusWeightTbl[PQMASK_MODULE_SRNN_IN_0+Module][j*8+k] = (Buf[j]*(16-k) + Buf[j+1]*k + 8) >> 4;
					}
				}
			}
		}

		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEFOCUS);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEFOCUS);
	}
#endif
	unsigned char Buf_256[PQMASK_MAPCURVE_LEN] = {0};
	int i=0;
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEFOCUS) != 0 ) {
		for(i=PQMASK_WEIGHT_SRNN_IN_0; i<PQMASK_WEIGHT_SRNN_MAX; i++) { // srnn.bin enum
			scalerPQMaskColor_Convert_srnn_depth_weight_curve_map(Buf+i*DEFOCUS_SRNN_LABEL_NUM, Buf_256);
			memcpy((void *)PQMaskColorMgr.DefocusWeightTbl[PQMASK_MODULE_SRNN_IN_0+i], (void *)Buf_256, sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEFOCUS);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEFOCUS);
	}
}

void scalerPQMaskColor_GetDefocusEnableTbl(unsigned char *Buf) {
	memcpy((void *)(Buf), (void *)PQMaskColorMgr.DefocusEnableTbl, sizeof(unsigned char)*PQMASK_MODULE_NUM);
}

void scalerPQMaskColor_SetDefocusEnableTbl(unsigned char *Buf) {
	memcpy((void *)PQMaskColorMgr.DefocusEnableTbl, (void *)(Buf), sizeof(unsigned char)*PQMASK_MODULE_NUM);
}

/**
 * @brief 
 * get defocus enable tbl (which pqmask needs defocus blending)
 * @param Buf 
 * @return Module 
 * Module == 0, SRNN IN0
 * Module == 1, SRNN IN1
 * Module == 2, SRNN IN2
 * Module == 3, SRNN OUT
 */
void scalerPQMaskColor_GetDefocusEnableTbl_SRNN(unsigned char *Buf) {
	memcpy((void *)(Buf), (void *)PQMaskColorMgr.DefocusEnableTbl+PQMASK_MODULE_SRNN_IN_0, sizeof(unsigned char)*PQMASK_WEIGHT_SRNN_MAX);
}

/**
 * @brief 
 * set defocus enable tbl (which pqmask needs defocus blending)
 * @param Buf 
 * @return Module 
 * Module == 0, SRNN IN0
 * Module == 1, SRNN IN1
 * Module == 2, SRNN IN2
 * Module == 3, SRNN OUT
 */
void scalerPQMaskColor_SetDefocusEnableTbl_SRNN(unsigned char *Buf) {
	memcpy((void *)PQMaskColorMgr.DefocusEnableTbl+PQMASK_MODULE_SRNN_IN_0, (void *)(Buf), sizeof(unsigned char)*PQMASK_WEIGHT_SRNN_MAX);
}


void scalerPQMaskColor_GetDepthWeight(unsigned char *Buf) {
	int i=0;
	for(i=0; i<PQMASK_MODULE_NUM; i++) {
		memcpy((void *)(Buf+i*PQMASK_MAPCURVE_LEN), (void *)PQMaskColorMgr.DepthWeightTbl[i], sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
	}
}

void scalerPQMaskColor_SetDepthWeight(unsigned char *Buf) {
	int i=0;
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEPTH) != 0) {
		for(i=0; i<PQMASK_MODULE_NUM; i++) {
			memcpy((void *)PQMaskColorMgr.DepthWeightTbl[i], (void *)(Buf+i*PQMASK_MAPCURVE_LEN), sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEPTH);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEPTH);
	}
}


void scalerPQMaskColor_SetSemanticWeight_SRNN(unsigned char * Buf) 
{
	int i=0;

	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_SEMANTIC) != 0  || PQMaskTableLock[PQMASK_COLOR_PALETTE_SEMANTIC].bIsInit == 0) {	//if pqmask is not init, set table directly
		for(i=PQMASK_WEIGHT_SRNN_IN_0; i<PQMASK_WEIGHT_SRNN_MAX; i++) { // srnn.bin enum
			memcpy((void *)PQMaskColorMgr.SemanticWeightTbl[PQMASK_MODULE_SRNN_IN_0+i], (void *)(Buf+i*SEM_SRNN_LABEL_NUM), sizeof(unsigned char)*PQMASK_LABEL_NUM);
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_SEMANTIC);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_SEMANTIC);
	}	
}

void scalerPQMaskColor_SetDepthWeight_SRNN(unsigned char * Buf) // for android, table from srnn.bin
{
	unsigned char Buf_256[PQMASK_MAPCURVE_LEN] = {0};
	int i=0;
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEPTH) != 0 ) {
		for(i=PQMASK_WEIGHT_SRNN_IN_0; i<PQMASK_WEIGHT_SRNN_MAX; i++) { // srnn.bin enum
			scalerPQMaskColor_Convert_srnn_depth_weight_curve_map(Buf+i*DEPTH_SRNN_LABEL_NUM, Buf_256);
			memcpy((void *)PQMaskColorMgr.DepthWeightTbl[PQMASK_MODULE_SRNN_IN_0+i], (void *)Buf_256, sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEPTH);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEPTH);
	}
}

void scalerPQMaskColor_SetSemanticWeight_AIPQ(unsigned char * Buf, unsigned char Buf_col_mode) // for android, table from aipq.bin
{
	int i=0;
	unsigned char num;
	if (Buf_col_mode == 1)
		num = SLR_AI_Sematic_Items_Max;
	else
		num = PQMASK_LABEL_NUM;
	
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_SEMANTIC) != 0 ) {
		for(i=PQMASK_MODULE_NR; i<PQMASK_MODULE_SRNN_IN_0; i++) { // aipq.bin enum
			memcpy((void *)PQMaskColorMgr.SemanticWeightTbl[PQMASK_MODULE_NR+i], (void *)(Buf+i*num), sizeof(unsigned char)*PQMASK_LABEL_NUM);
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_SEMANTIC);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_SEMANTIC);
	}	
}

void scalerPQMaskColor_SetDepthWeight_AIPQ(unsigned char * Buf) // for android, table from aipq.bin
{
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEPTH) != 0 ) {
		memcpy((void *)PQMaskColorMgr.DepthWeightTbl, Buf, PQMASK_MODULE_SRNN_IN_0*PQMASK_MAPCURVE_LEN*sizeof(unsigned char));

		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEPTH);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEPTH);
	}
}

char ScalerPQMaskColor_SQMWeight_AIPQ_BIN(unsigned char mode)
{
#if IS_ENABLED(CONFIG_RTK_AI_DRV)
#ifndef BUILD_QUICK_SHOW
	unsigned char i, j, idx;
#ifdef VIP_SUPPORT_AIPQ_NNSR_BIN_V2
	if (mode == 0) {
		for (i=0;i<AI_RESOLUTION_TYPE_NUM;i++)
			for (j=0;j<PQMASK_MODULE_SRNN_IN_0;j++)
				AI_PQMaskWeightTbl_SQM_TBL[i][j] = 0;
	} 
	else 
	{
		idx = (mode == 1)?(0):(1);
		for (i=0;i<AI_RESOLUTION_TYPE_NUM;i++)
			for (j=0;j<PQMASK_MODULE_SRNN_IN_0;j++)
				AI_PQMaskWeightTbl_SQM_TBL[i][j] = m_VIP_AIPQTable.SQD_TBL[idx][i][j];
	}
#else
	if (mode == 0) {
		for (i=0;i<AI_RESOLUTION_TYPE_NUM;i++)
			for (j=0;j<PQMASK_MODULE_SRNN_IN_0;j++)
				AI_PQMaskWeightTbl_SQM_TBL[i][j] = 0;
	} 
	else 
	{
		idx = (mode == 1)?(0):(1);
		for (i=0;i<AI_RESOLUTION_TYPE_NUM;i++)
			for (j=0;j<PQMASK_MODULE_SRNN_IN_0;j++)
				AI_PQMaskWeightTbl_SQM_TBL[i][j] = m_VIP_AIPQTable.SQM_TBL[idx][i][j];
	}
#endif	
	scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEPTH);
	scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_SEMANTIC);						
#endif
#endif
	return 0;
}

char ScalerPQMaskColor_PQMASK_Smooth_AIPQ_BIN(RTK_AI_PQ_mode *ap_mode, SLR_AI_PQ_mask_Smooth_Control *pAI_PQ_mask_Smooth_Control)
{
	//int depth, semantic, defocus;
	if (pAI_PQ_mask_Smooth_Control == NULL) {
		rtd_pr_vpq_info("[%s] NULL ponit\n", __FUNCTION__);
		return -1;
	}

	//depth = (ap_mode->depth_mode==1)?(1):(0);
	//semantic = (ap_mode->semantic_mode==1)?(1):(0);
	//defocus = (ap_mode->defocus_mode==1)?(1):(0);
	
	PQMaskColorMgr.Param.FusionRatio_Dep = pAI_PQ_mask_Smooth_Control->Blending_Weight[SLR_AI_pqMask_smooth_ctrl_depth];
	PQMaskColorMgr.Param.FusionRatio_Sem = pAI_PQ_mask_Smooth_Control->Blending_Weight[SLR_AI_pqMask_smooth_ctrl_sematic];	
	PQMaskColorMgr.Param.FusionRatio_Defocus = pAI_PQ_mask_Smooth_Control->Blending_Weight[SLR_AI_pqMask_smooth_ctrl_defocus];
	PQMaskColorMgr.Param.FusionRatio_Pre = pAI_PQ_mask_Smooth_Control->Temporal_Filter[SLR_AI_pqMask_smooth_ctrl_pre];
	PQMaskColorMgr.Param.FusionRatio_Cur = pAI_PQ_mask_Smooth_Control->Temporal_Filter[SLR_AI_pqMask_smooth_ctrl_current];
#ifdef VIP_SUPPORT_AIPQ_NNSR_BIN_V2
	PQMaskColorMgr.Param.DepthFusiontRatio_Pre = pAI_PQ_mask_Smooth_Control->Temporal_Filter[SLR_AI_pqMask_smooth_ctrl_depth_pre];
	PQMaskColorMgr.Param.DepthFusiontRatio_Cur = pAI_PQ_mask_Smooth_Control->Temporal_Filter[SLR_AI_pqMask_smooth_ctrl_depth_cur];	
#endif
	PQMaskColorMgr.Param.SpatialFltCycle = pAI_PQ_mask_Smooth_Control->Spatial_Filter[SLR_AI_pqMask_smooth_ctrl_Spatial_Filter];

	return 0;
}

void scalerPQMaskColor_Convert_srnn_defocus_weight_curve_map(unsigned char *defocus_weight_in, unsigned char *defocus_weight_out)
{
	int i, j, idx, diff, base;
	for (i = 0; i < DEFOCUS_SRNN_LABEL_NUM-1; i++)
	{
		diff = defocus_weight_in[i+1] - defocus_weight_in[i];
		base = defocus_weight_in[i] * 8;
		idx = i*8;
		for (j = 0;j < 8; j++) {
			defocus_weight_out[idx+j] = (base+diff*j)>>3;
		}
	}
	defocus_weight_out[PQMASK_MAPCURVE_LEN-2] = defocus_weight_out[PQMASK_MAPCURVE_LEN-1] = defocus_weight_in[DEFOCUS_SRNN_LABEL_NUM-1];
}

void scalerPQMaskColor_SetDeFocus_SRNN(unsigned char *Buf) // for android, table from srnn.bin
{
	static unsigned char Buf_256[PQMASK_MAPCURVE_LEN] = {0};
	int i=0;
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEFOCUS) != 0 ) {
		for(i=PQMASK_WEIGHT_SRNN_IN_0; i<PQMASK_WEIGHT_SRNN_MAX; i++) { // srnn.bin enum
			scalerPQMaskColor_Convert_srnn_defocus_weight_curve_map(Buf+i*DEFOCUS_SRNN_LABEL_NUM, Buf_256);
			memcpy((void *)PQMaskColorMgr.DefocusWeightTbl[PQMASK_MODULE_SRNN_IN_0+i], (void *)Buf_256, sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
		}
		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEFOCUS);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEFOCUS);
	}
}

void scalerPQMaskColor_SetDeFocus_AIPQ(unsigned char *Buf) // for android, table from aipq.bin
{
	if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEFOCUS) != 0 ) {
		memcpy((void *)PQMaskColorMgr.DefocusWeightTbl, Buf, PQMASK_MODULE_SRNN_IN_0*PQMASK_MAPCURVE_LEN*sizeof(unsigned char));

		scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEFOCUS);
		scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEFOCUS);
	}
}

// V4L2 commands
/**
 * @brief
 * support V4L2 command
 * @param ModuleSel
 * module to set the weight
 * @param Buf
 * input depth weight, assume data type is unsigned char
 * @return int
 * status
 */
int scalerPQMask_V4L2_SetDepthWeight(unsigned char ModuleSel, unsigned char *Buf) {

	int i=0;
	unsigned char CompareResult = 1; // 0: need reload, 1: same data, no need to reload
	unsigned char *TablePtr = NULL;

	if( ModuleSel >= PQMASK_MODULE_NUM ) {
		rtd_pr_vpq_info("[%s] ModuleSel = %d error\n", __FUNCTION__, ModuleSel);
		return -1;
	}

#if 0
	if( ModuleSel == PQMASK_MODULE_LC ) {
		rtd_printk(KERN_DEBUG, TAG_NAME, "[%s] LocalContrast should use another function\n", __FUNCTION__);
		return -1;
	}
#endif

	// check the table is the same or not
	for( i=0; i<PQMASK_MAPCURVE_LEN; i++ ) {
		if( PQMaskColorMgr.DepthWeightTbl[ModuleSel][i] != Buf[i] ) {
			CompareResult = 0;
		}
	}

	if( CompareResult == 0 ) {

		if( scalerPQMaskColor_LockTable(PQMASK_COLOR_PALETTE_DEPTH) != 0 ) {
			// copy the table to internal source table
			TablePtr = (unsigned char *)scaler_VIP_PQMask_GetDepthTable(0);
			if( TablePtr != NULL ) {
				memcpy((void *)(TablePtr + ModuleSel*PQMASK_MAPCURVE_LEN*sizeof(unsigned char)), (void *)Buf, PQMASK_MAPCURVE_LEN*sizeof(unsigned char));
			} else {
				rtd_pr_vpq_info("[%s] get depth weight table fail\n", __FUNCTION__);
			}

			// copy the table to local module use table
			memcpy((void *)PQMaskColorMgr.DepthWeightTbl[ModuleSel], (void *)Buf, sizeof(unsigned char)*PQMASK_MAPCURVE_LEN);
			// Hue weighing is the blending ratio with target hue
			if( ModuleSel == PQMASK_MODULE_HUE ) {
				for(i=0; i<PQMASK_MAPCURVE_LEN; i++ ) {
					PQMaskColorMgr.DepthWeightTbl[ModuleSel][i] = (PQMaskColorMgr.DepthWeightTbl[ModuleSel][i] - 128) * 2;
				}
			}

			// set reload
			scalerPQMaskColor_SetReloadPalette(PQMASK_COLOR_PALETTE_DEPTH);
			scalerPQMaskColor_UnLockTable(PQMASK_COLOR_PALETTE_DEPTH);
		}
	}

	return 0;
}

/**
 * @brief 
 * support V4L2 command
 * @return unsigned int 
 * depth information apl
 */
unsigned int scalerPQMask_V4L2_GetDepthAPL(void) {
	return PQMaskColorMgr.DepthHist.Data.Apl;
}

//====for Demo Use Start====Remove it after Demo====
#if 0 
void scalerPQMaskColor_SetFunction_En(unsigned char bEn) {

	DRV_LC_ToneMapping_PQmask LCTmap;
	DRV_LC_Sharpness_PQmask LCSharp;

	rtd_pr_vpq_info( "[%s] start\n", __FUNCTION__);

	// initial some structure

	// NR
	// (drvif_color_DRV_SNR_PQ_Mask)(drvif_color_Set_Block_DeContour_Ctrl), setting vip_default_panel.c
	PQMaskColorMgr.ModuleSetting.Nr.bNrEnable =bEn;
	PQMaskColorMgr.ModuleSetting.Nr.bIDecontEnable =bEn;
	PQMaskColorMgr.ModuleSetting.Nr.bIBlockDecontEnable=bEn;
	drvif_color_DRV_SNR_PQ_Mask_Enable(PQMaskColorMgr.ModuleSetting.Nr.bNrEnable);
	drvif_color_Set_I_De_Contour_PQ_Mask_Enable(PQMaskColorMgr.ModuleSetting.Nr.bIDecontEnable);
	drvif_color_Set_Block_DeContour_PQ_Mask_Enable(PQMaskColorMgr.ModuleSetting.Nr.bIBlockDecontEnable);

	// ICM
	PQMaskColorMgr.ModuleSetting.ICM.bHueEnable =bEn;
	PQMaskColorMgr.ModuleSetting.ICM.bSatEnable =bEn;
	PQMaskColorMgr.ModuleSetting.ICM.bIntEnable =bEn;
	drvif_color_icm_Set_pqmask_hue(PQMaskColorMgr.ModuleSetting.ICM.bHueEnable, PQMaskColorMgr.ModuleSetting.ICM.HueGain);
	drvif_color_icm_Set_pqmask_sat(PQMaskColorMgr.ModuleSetting.ICM.bSatEnable, PQMaskColorMgr.ModuleSetting.ICM.SatGain, PQMaskColorMgr.ModuleSetting.ICM.SatOffset);
	drvif_color_icm_Set_pqmask_int(PQMaskColorMgr.ModuleSetting.ICM.bIntEnable, PQMaskColorMgr.ModuleSetting.ICM.IntGain, PQMaskColorMgr.ModuleSetting.ICM.IntOffset);

	// Sharpness
	drvif_sharpness_pq_mask_en(bEn);

	//LC
	PQMaskColorMgr.ModuleSetting.LocalContrast.bToneMappingEnable =bEn;
	PQMaskColorMgr.ModuleSetting.LocalContrast.bSharpEnable =bEn;
	LCTmap.lc_PQmask_tmap_En = PQMaskColorMgr.ModuleSetting.LocalContrast.bToneMappingEnable;
	LCTmap.lc_PQmask_offset = PQMaskColorMgr.ModuleSetting.LocalContrast.ToneMappingOffset;
	LCTmap.lc_PQmask_tmap_gain = PQMaskColorMgr.ModuleSetting.LocalContrast.ToneMappingGain;
	LCSharp.lc_PQmask_shp_En = PQMaskColorMgr.ModuleSetting.LocalContrast.bSharpEnable;
	LCSharp.lc_PQmask_shp_gain = PQMaskColorMgr.ModuleSetting.LocalContrast.SharpGain;
	LCSharp.lc_PQmask_shp_offset = PQMaskColorMgr.ModuleSetting.LocalContrast.SharpOffset;
	drvif_color_set_LC_Tonemapping_PQmask(&LCTmap);
	drvif_color_set_LC_Sharpness_PQmask(&LCSharp);

	rtd_pr_vpq_info( "[%s] end\n", __FUNCTION__);

}

#include <rbus/color_reg.h>
#include <tvscalercontrol/io/ioregdrv.h>
void scalerPQMaskColor_Function_En_CheckDummyRegister(void)
{
	static unsigned char pre_pq_mask_en = 0;
	unsigned char pq_mask_en = 0;
	pq_mask_en = COLOR_D_VC_Global_CTRL_get_dummy_30_27(IoReg_Read32(COLOR_D_VC_Global_CTRL_reg))>>3;
	if (pre_pq_mask_en != pq_mask_en) {
		scalerPQMaskColor_SetFunction_En(pq_mask_en);
		pre_pq_mask_en = pq_mask_en;
	}
}
#endif
#endif
//====for Demo Use End====Remove it after Demo====
